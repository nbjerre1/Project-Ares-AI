import socket
import json
import random

ACTIONS = ["move_left", "move_right", "move_up", "move_down"]

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('localhost', 12345))
sock_file = sock.makefile('r')

log_file = open("data.jsonl", "a")

try:
    while True:
        line = sock_file.readline()
        if not line:
            break

        state = json.loads(line)
        print("State from Godot:", state)

        def is_move_valid(x, y, action, state):
            # Define world bounds
            min_x, max_x = 0, 20
            min_y, max_y = 0, 20

            # Calculate new position
            if action == "move_left":
                new_x, new_y = x - 1, y
            elif action == "move_right":
                new_x, new_y = x + 1, y
            elif action == "move_up":
                new_x, new_y = x, y - 1
            elif action == "move_down":
                new_x, new_y = x, y + 1
            else:
                return False

            # Check world bounds
            if not (min_x <= new_x <= max_x and min_y <= new_y <= max_y):
                return False

            # Check obstacles
            for obs in state.get("obstacles", []):
                if obs["x"] == new_x and obs["y"] == new_y:
                    return False

            return True

        def choose_action(state):
            mob_positions = state.get("mobs", [])
            player_x, player_y = state["x"], state["y"]

            if not mob_positions:
                # Only choose valid random actions
                valid_actions = [a for a in ACTIONS if is_move_valid(player_x, player_y, a, state)]
                return random.choice(valid_actions) if valid_actions else None

            closest_mob = min(
                mob_positions,
                key=lambda mob: (player_x - mob["x"]) ** 2 + (player_y - mob["y"]) ** 2
            )
            mob_x, mob_y = closest_mob["x"], closest_mob["y"]
            dx = player_x - mob_x
            dy = player_y - mob_y

            # Try to move away from mob, but only if valid
            preferred = []
            if abs(dx) > abs(dy):
                return "move_right" if dx > 0 else "move_left"
            else:
                return "move_down" if dy > 0 else "move_up"

            # Add other directions as fallback
            for a in ACTIONS:
                if a not in preferred:
                    preferred.append(a)

            for action in preferred:
                if is_move_valid(player_x, player_y, action, state):
                    return action

            return None

        action = choose_action(state)

        # Log the state and action
        log_entry = {
            "x": state["x"],
            "y": state["y"],
            "health": state["health"],
            "timer": state["timer"],  # Include 'timer' as part of the state
            "mobs": state.get("mobs", []),
            "action": action
        }
        log_file.write(json.dumps(log_entry) + "\n")
        log_file.flush()

        sock.sendall((action + "\n").encode())

except KeyboardInterrupt:
    print("Stopped by user")
except Exception as e:
    print("Python error:", e)
finally:
    sock.close()
    log_file.close()
